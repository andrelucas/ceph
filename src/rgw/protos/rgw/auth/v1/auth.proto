syntax = "proto3";

package rgw.auth.v1;

service AuthService
{
  // Given an S3 request, attempt to authenticate a user id.
  rpc Auth(AuthRequest) returns (AuthResponse);
  // Simple ping-like service, useful for service liveness checks.
  rpc Status(StatusRequest) returns (StatusResponse);
}

// Types of S3 HTTP request, may be useful for authorization decisions.
enum RequestMethod {
  REQUEST_METHOD_UNSPECIFIED = 0;
  REQUEST_METHOD_GET = 1;
  REQUEST_METHOD_PUT = 2;
  REQUEST_METHOD_POST = 3;
  REQUEST_METHOD_DELETE = 4;
  REQUEST_METHOD_HEAD = 5;
}

// Information about the request not normally provided to RGW authentication
// engines, but required for authorization decisions and more advanced
// authentication scenarios.
//
message AuthorizationParameters
{
  // The HTTP request method.
  RequestMethod method = 1;

  // The bucket name, or empty if none.
  string bucket_name = 2;

  // The object key name, or empty if none.
  string object_key_name = 3;

  // Request HTTP headers, as a map from header name to header value.
  map<string, string> http_headers = 5;

  // The canonicalised request URI path. In RGW this is the `request_uri`
  // field in struct req_info. Note that this is normalised; if the request
  // was in virtual host form, the bucket name will have been prepended to
  // this path.
  string http_request_path = 6;

  // The request query parameters as parsed by RGW in
  // RGWHandler_REST_S3::init_from_header(). Note these are URL decoded
  // already.
  map<string, string> http_query_parameters = 7;
}

// The type of user in question. For a request, this is used to inform the
// authentication service that the request being authorised is anonymous, i.e.
// no authentication is possible or requested.
//
// For a response, this is used to inform RGW that the response is to an
// anonymous request, and that no authentication was performed.
//
// This is used to check for logical errors; the caller should check that the
// response type matches the request type, and fail the operation if they do
// not match.
//
enum AuthUserType {
  // This is the default, a regular user.
  AUTH_USER_TYPE_UNSPECIFIED = 0;

  // The user is anonymous, i.e. not authenticated, but may be authorised.
  AUTH_USER_TYPE_ANONYMOUS = 1;
}

// An authentication request to the Auth() service call.
//
// This closely mirrors
// the parameters passed to RGW external authentication 'engine' classes, but
// with additional fields for Akamai-specific authentication and authorization
// purposes.
//
message AuthRequest
{
  // The user type. If AUTH_USER_TYPE_ANONYMOUS, then the request is
  // (obviously) anonymous, so does not require authentication. In that case,
  // the values of most other authentication parameters are irrelevant (and
  // should be empty). However, AuthroizationParameters should still be sent,
  // otherwise there's no value in using Handoff.
  AuthUserType user_type = 6;

  // The stringToSign as defined by AWS.
  string string_to_sign = 1;

  // The access_key_id field. This is also present in the v4
  // Authorization header, but not the v2 header, so it needs to be included.
  string access_key_id = 2;

  // The Authorization header. Presigned URLs don't have these, but the RGW
  // Handoff implementation synthesises one based on the query string
  // parameters.
  string authorization_header = 3;

  // The x-amz-authorization-token header, or an empty string.
  string authorization_token_header = 5;

  // Additional parameters we may have inferred from the request. Note that
  // not all information about the query is known at authentication time, and
  // there is a cost in both time and development complexity to prefetching
  // this information.
  optional AuthorizationParameters param = 4;
}

// AuthCode enumeration, for HTTP-like error responses. At the time of
// creation these largely match HTTP semantics, but it's conceivable that
// this may change over time as more specific failure modes become available.
//
enum AuthCode {
  // Default value.
  AUTH_CODE_UNSPECIFIED = 0;
  // User is authenticated, and the UID field in AuthResponse has a valid user
  // id. AuthResponse.message may hold further information but its contents
  // are likely to be uninformative.
  AUTH_CODE_OK = 200;
  // There was a problem with the request. AuthResponse.message may hold more
  // information about the specific problem.
  AUTH_CODE_BAD_REQUEST = 400;
  // Authentication failed. The user's credentials were not verified. Message
  // may hold more specific information.
  AUTH_CODE_UNAUTHORIZED = 401;
  // Authorization failed for some reason other than failed authentication,
  // e.g. some request parameters were missing or malformed. Message may hold
  // more specific information.
  AUTH_CODE_FORBIDDEN = 403;
  // Authorization failed because the access key id could not be found.
  AUTH_CODE_NOTFOUND = 404;
  // Authorization failed for some external reason such as server failure.
  // AuthResponse.message may hold more specific information.
  AUTH_CODE_FAILURE = 500;
}

// The Authentication service's response to an Auth() service call. The uid is
// very important, as it provides a mapping from the request's access_key_id
// to an actual user id.
//
message AuthResponse
{
  // The user type. Typically this will be AUTH_USER_TYPE_UNSPECIFIED for
  // regular users, but anonymous requests will (unsurprisingly) have
  // AUTH_USER_TYPE_ANONYMOUS.
  AuthUserType user_type = 4;

  // The uid associated with the original request. RGW absolutely requires
  // this to be properly set.
  string uid = 1;
  // Optional information about the authentication process. Will most likely
  // be logged, so must not include confidential information.
  string message = 2;
  // Enumeration with the response status. Anything other than AUTH_CODE_OK
  // will return a deny token to RGW.
  AuthCode code = 3;
}

// Request for the Status() rpc.
message StatusRequest
{
  // Nothing.
}

// Response for the Status() rpc.
message StatusResponse
{
  // A arbitrary string describing the server implementation.
  string server_description = 1;
}
