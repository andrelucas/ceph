// -*- mode:C++; tab-width:8; c-basic-offset:2; indent-tabs-mode:t -*-
// vim: ts=8 sw=2 smarttab

#include <cstdint>
#include <grpcpp/support/channel_arguments.h>
#include <iostream>
#include <optional>
#include <string>
#include <thread>
#include <unordered_map>
#include <vector>

#include <absl/random/random.h>
#include <boost/algorithm/hex.hpp>
#include <boost/regex.hpp>
#include <fmt/format.h>
#include <gmock/gmock-matchers.h>
#include <google/protobuf/util/json_util.h>
#include <google/protobuf/util/time_util.h>
#include <grpc/grpc.h>
#include <grpcpp/channel.h>
#include <grpcpp/client_context.h>
#include <grpcpp/create_channel.h>
#include <gtest/gtest.h>
#include <openssl/evp.h>

#include "common/async/yield_context.h"
#include "common/ceph_argparse.h"
#include "common/ceph_context.h"
#include "common/dout.h"
#include "common/strtol.h"
#include "global/global_context.h"
#include "global/global_init.h"
#include "include/ceph_assert.h"
#include "rgw/rgw_b64.h"
#include "rgw/rgw_client_io.h"
#include "rgw/rgw_handoff.h"
#include "rgw/rgw_handoff_impl.h"
#include "rgw/rgw_http_client.h"
#include "rgw/rgw_process_env.h"

// Despite clangd's assertions, the following two includes are necessary
// because there are a couple of static asserts in RGWProcessEnv that check
// that rgw::sal::LuaManager and rgw::auth::StrategyRegistry are of size > 0.
#include "rgw/rgw_sal.h"
#include "rgw_auth_registry.h"

#include "rgw_iam_policy.h"
#include "rgw_rest_s3.h"
#include "test_rgw_grpc_util.h"

// These are 'standard' protobufs for the 'Richer error model'
// (https://grpc.io/docs/guides/error/).
#include "google/rpc/status.pb.h"

// This is the protobuf for the authenticator service, copied from
// obj-endpoint.
#include "authenticator/v1/authenticator.grpc.pb.h"
#include "authenticator/v1/authenticator.pb.h"

#include "authorizer/v1/authorizer.grpc.pb.h"
#include "authorizer/v1/authorizer.pb.h"

#pragma clang diagnostic error "-Wsign-conversion"
#pragma GCC diagnostic error "-Wsign-conversion"

/*
 * Tools tests.
 */

namespace {

/* #region TestData */

// The information we need to use an access key.
struct AccessKeyInfo {
  std::string userid;
  std::string secret;
};

static std::unordered_map<std::string, AccessKeyInfo>
    super_secret_vault = {
      // This is the 'testid' user created by many tests, and installed by
      // default into dbstore.
      { "0555b35654ad1656d804", { "testid", "h7GhxuBLTrlhVUyxSPUKUV8r/2EI4ngqJxD7iBdBYLhwluN30JaT3Q==" } },
      { "AKIAIOSFODNN7EXAMPLE", { "awsquerystringexample", "wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY" } }
    };

// Look up the userid and secret for a given credential (access key id).
static std::optional<AccessKeyInfo>
info_for_credential(const std::string& access_key)
{
  auto srch = super_secret_vault.find(access_key);
  if (srch == super_secret_vault.end()) {
    return std::nullopt;
  }
  return std::make_optional(srch->second);
}

struct HandoffHdrTestData {
  std::string name;
  /// @brief The string_to_sign field.
  std::string ss_base64;
  std::string access_key;
  std::string signature;
  std::string authorization;
};

static HandoffHdrTestData sigpass_tests[]
    = {
        // This is generated by `s3cmd ls s3://test` with the bucket test
        // pre-created. V4 signature.
        {
            "s3cmd ls s3://test",
            "QVdTNC1ITUFDLVNIQTI1NgoyMDIzMDcxMFQxNjQ1MzJaCjIwMjMwNzEwL3VzLWVhc3QtMS9zMy9hd3M0X3JlcXVlc3QKNTgxYzA3NzEzYjRmODFjYmQ4YTFiN2NhN2ZiNzU4YTkyMzVmYzQyYzZjZmZjZDgyMTIxNjdiMjA2NmJjODIwMg==",
            "0555b35654ad1656d804",
            "616427c5112796fde309f6620ae2542b6c493e7c84026771d2e9f94af2b5150b",
            "AWS4-HMAC-SHA256 Credential=0555b35654ad1656d804/20230710/us-east-1/s3/aws4_request,SignedHeaders=host;x-amz-content-sha256;x-amz-date,Signature=616427c5112796fde309f6620ae2542b6c493e7c84026771d2e9f94af2b5150b",
        },
        // This is generated by
        //   `dd if=/dev/urandom bs=4096 count=1 | s3cmd put - s3://test/rand1`
        // V4 signature.
        {
            "dd ... | s3cmd put - s3://test/rand1",
            "QVdTNC1ITUFDLVNIQTI1NgoyMDIzMDcxMVQxNDMwMTRaCjIwMjMwNzExL3VzLWVhc3QtMS9zMy9hd3M0X3JlcXVlc3QKNGQ1ZDg2N2NiODBmMmU3Y2FlMGM5YmZmMWUxYTE4YmYyMmJjMmY4NWYzYjVjNzY0Nzg1MTYzNTA4MjljODhkZQ",
            "0555b35654ad1656d804",
            "0c7838f249db0668d832d78feb1a3fd55606dbe0e630592411c83f18ed8d465c",
            "AWS4-HMAC-SHA256 Credential=0555b35654ad1656d804/20230711/us-east-1/s3/aws4_request,SignedHeaders=content-length;host;x-amz-content-sha256;x-amz-date,Signature=0c7838f249db0668d832d78feb1a3fd55606dbe0e630592411c83f18ed8d465c" },
        // This is generated by
        //   `s3cmd ls s3://test` with nothing in the bucket.
        // V2 signature.
        {
            "s3cmd ls s3://test (empty -> v2 auth)",
            "R0VUCgoKCngtYW16LWRhdGU6VHVlLCAxMSBKdWwgMjAyMyAxNzoxMDozOCArMDAwMAovdGVzdC8=",
            "0555b35654ad1656d804",
            "ZbQ5cA54KqNak3O2KTRTwX5YzUE=",
            "AWS 0555b35654ad1656d804:ZbQ5cA54KqNak3O2KTRTwX5YzUE=" }
      };

HandoffHdrTestData sigfail_tests[]
    = {
        // This is generated by `s3cmd ls s3://test` with the bucket test
        // pre-created. V4 signature. stringToSign corrupted, but carefully
        // since it's base64 encoded - if we just randomly corrupt it, we
        // might get invalid utf-8 which upsets gRPC.
        {
            "xfail (access_key): s3cmd ls s3://test",
            "QVdTNC1ITUFDLVNIQTI1NgoyMDIzMDcxMFQxNjQ1MzJaCjIwMjMwNzEwL3VzLWVhc3QtMS9zMy9hd3M0X3JlcXVlc3QKNjgxYzA3NzEzYjRmODFjYmQ4YTFiN2NhN2ZiNzU4YTkyMzVmYzQyYzZjZmZjZDgyMTIxNjdiMjA2NmJjODIwMgo=",
            "1555b35654ad1656d804",
            "616427c5112796fde309f6620ae2542b6c493e7c84026771d2e9f94af2b5150b",
            "AWS4-HMAC-SHA256 Credential=0555b35654ad1656d804/20230710/us-east-1/s3/aws4_request,SignedHeaders=host;x-amz-content-sha256;x-amz-date,Signature=616427c5112796fde309f6620ae2542b6c493e7c84026771d2e9f94af2b5150b",
        }, // This is generated by `s3cmd ls s3://test` with the bucket test
           // pre-created. V4 signature. access_key corrupted (but note it's the
           // same wrong value in the authorization header - RGW would normally
           // parse the access key out of the header, and it's confusing to have
           // it wrong in the access key field but correct in the header).
        {
            "xfail (access_key): s3cmd ls s3://test",
            "QVdTNC1ITUFDLVNIQTI1NgoyMDIzMDcxMFQxNjQ1MzJaCjIwMjMwNzEwL3VzLWVhc3QtMS9zMy9hd3M0X3JlcXVlc3QKNTgxYzA3NzEzYjRmODFjYmQ4YTFiN2NhN2ZiNzU4YTkyMzVmYzQyYzZjZmZjZDgyMTIxNjdiMjA2NmJjODIwMg==",
            "1555b35654ad1656d804",
            "616427c5112796fde309f6620ae2542b6c493e7c84026771d2e9f94af2b5150b",
            "AWS4-HMAC-SHA256 Credential=1555b35654ad1656d804/20230710/us-east-1/s3/aws4_request,SignedHeaders=host;x-amz-content-sha256;x-amz-date,Signature=616427c5112796fde309f6620ae2542b6c493e7c84026771d2e9f94af2b5150b",
        },
        // This is generated by
        //   `dd if=/dev/urandom bs=4096 count=1 | s3cmd put - s3://test/rand1`
        // V4 signature. Signature corrupted.
        {
            "xfail (sig): dd ... | s3cmd put - s3://test/rand1",
            "QVdTNC1ITUFDLVNIQTI1NgoyMDIzMDcxMVQxNDMwMTRaCjIwMjMwNzExL3VzLWVhc3QtMS9zMy9hd3M0X3JlcXVlc3QKNGQ1ZDg2N2NiODBmMmU3Y2FlMGM5YmZmMWUxYTE4YmYyMmJjMmY4NWYzYjVjNzY0Nzg1MTYzNTA4MjljODhkZQ",
            "0555b35654ad1656d804",
            "0c7838f249db0668d832d78feb1a3fd55606dbe0e630592411c83f18ed8d465c",
            "AWS4-HMAC-SHA256 Credential=0555b35654ad1656d804/20230711/us-east-1/s3/aws4_request,SignedHeaders=content-length;host;x-amz-content-sha256;x-amz-date,Signature=1c7838f249db0668d832d78feb1a3fd55606dbe0e630592411c83f18ed8d465c" },
        // This is generated by
        //   `dd if=/dev/urandom bs=4096 count=1 | s3cmd put - s3://test/rand1`
        // V4 signature. Authorization header corrupted.
        {
            "xfail (authhdr): dd ... | s3cmd put - s3://test/rand1",
            "QVdTNC1ITUFDLVNIQTI1NgoyMDIzMDcxMVQxNDMwMTRaCjIwMjMwNzExL3VzLWVhc3QtMS9zMy9hd3M0X3JlcXVlc3QKNGQ1ZDg2N2NiODBmMmU3Y2FlMGM5YmZmMWUxYTE4YmYyMmJjMmY4NWYzYjVjNzY0Nzg1MTYzNTA4MjljODhkZQ",
            "0555b35654ad1656d804",
            "0c7838f249db0668d832d78feb1a3fd55606dbe0e630592411c83f18ed8d465c",
            "AWS4-HMAC-SHA256 Credential=0555b35654ad1656d804/20230711/xs-east-1/s3/aws4_request,SignedHeaders=content-length;host;x-amz-content-sha256;x-amz-date,Signature=0c7838f249db0668d832d78feb1a3fd55606dbe0e630592411c83f18ed8d465c" },
        // This is generated by
        //   `s3cmd ls s3://test` with nothing in the bucket.
        // V2 signature. stringToSign corrupted.
        {
            "xfail (v2 access key): s3cmd ls s3://test (empty -> v2 auth)",
            "00VUCgoKCngtYW16LWRhdGU6VHVlLCAxMSBKdWwgMjAyMyAxNzoxMDozOCArMDAwMAovdGVzdC8=",
            "0555b35654ad1656d804",
            "ZbQ5cA54KqNak3O2KTRTwX5YzUE=",
            "AWS 0555b35654ad1656d804:ZbQ5cA54KqNak3O2KTRTwX5YzUE=" }
      };

// This is generated by
//   `s3cmd ls s3://test` with nothing in the bucket.
// V2 signature.
HandoffHdrTestData v2_sample = {
  "v2_sample",
  "R0VUCgoKCngtYW16LWRhdGU6VHVlLCAxMSBKdWwgMjAyMyAxNzoxMDozOCArMDAwMAovdGVzdC8=",
  "0555b35654ad1656d804",
  "ZbQ5cA54KqNak3O2KTRTwX5YzUE=",
  "AWS 0555b35654ad1656d804:ZbQ5cA54KqNak3O2KTRTwX5YzUE="
};

struct HandoffQueryTestData {
  std::string name;
  std::string access_key;
  std::string presignedUrl;
};

HandoffQueryTestData presigned_pass_tests[] = {
  { "'s3cmd signurl s3://testnv/rand +3600' at 1696590328",
      "0555b35654ad1656d804",
      "http://amygdala-ub01.home.ae-35.com:8000/testnv/rand?AWSAccessKeyId=0555b35654ad1656d804&Expires=1696593928&Signature=2yvZEGjagY%2B5nyk9IcBOR%2Bu5KT8%3D" }
};

struct HandoffV4SigningKeyData {
  std::string name;
  std::string header;
  std::string signing_key_hex;
};

// Generated using the python client and server.
static HandoffV4SigningKeyData sk_pass[] = {
  { // Basic pass.
      "rgw std 20231113 from python client",
      "AWS4-HMAC-SHA256 Credential=0555b35654ad1656d804/20231113/us-east-1/s3/aws4_request, SignedHeaders=content-md5;host;x-amz-content-sha256;x-amz-date, Signature=2d139a3564b7795d859f5ce788b0d7a0f0c9028c8519b381c9add9a72345aac",
      "adc9095910047d23e416b24d4d1edf1bcd386fcc58d3307a159e8caf2bdb613e" },
  { // Same as previous, but one day later. The signature has to change.
      "rgw std 20231114 from python client",
      "AWS4-HMAC-SHA256 Credential=0555b35654ad1656d804/20231114/us-east-1/s3/aws4_request, SignedHeaders=content-md5;host;x-amz-content-sha256;x-amz-date, Signature=2d139a3564b7795d859f5ce788b0d7a0f0c9028c8519b381c9add9a72345aac",
      "4e8beb5c49ca3a6c977a6463bb85ff484ac4fc524114af9c926a4dc01c6a8500" }
};

/* #endregion */
/* #region SupportCode */

namespace ba = boost::algorithm;

// Wrap the rigmarole of hashing a buffer with OpenSSL.
static std::optional<std::vector<uint8_t>> _hash_by(const std::vector<uint8_t>& key, const std::string& input, const std::string& hash_type)
{
  auto pkey = EVP_PKEY_new_mac_key(EVP_PKEY_HMAC, NULL, key.data(), key.size());
  auto md = EVP_get_digestbyname(hash_type.c_str());
  auto ctx = EVP_MD_CTX_new();
  if (!EVP_DigestSignInit(ctx, NULL, md, NULL, pkey)) {
    std::cerr << "HMAC ctx init failed" << std::endl;
    return std::nullopt;
  }
  if (!EVP_DigestSignUpdate(ctx, input.data(), input.size())) {
    std::cerr << "HMAC update failed" << std::endl;
    return std::nullopt;
  }
  std::vector<uint8_t> hash(static_cast<size_t>(EVP_MD_size(md)));
  size_t hsiz = hash.size();
  if (!EVP_DigestSignFinal(ctx, hash.data(), &hsiz) || static_cast<int>(hsiz) != EVP_MD_size(md)) {
    std::cerr << "HMAC final failed" << std::endl;
    return std::nullopt;
  }
  EVP_MD_CTX_free(ctx);
  return std::make_optional(hash);
}

// Match the fields out of the V4 Authorization header.
static boost::regex re_v4_auth { "^AWS4-HMAC-SHA256\\sCredential=(?<accesskey>[0-9a-f]+)/(?<date>\\d+)"
                                 "/(?<region>[0-9a-z-]+)"
                                 "/(?<service>[0-9a-z-]+)"
                                 "/aws4_request"
                                 ",\\s*SignedHeaders=(?<signhdr>[-;a-z0-9]+)"
                                 ",\\s*Signature=(?<sig>[0-9a-f]+)"
                                 "$" };

/**
 * @brief Given the inputs, create an AWS v4 signing key. Return nullopt on
 * error, though it's hard to see why any of this would error.
 *
 * @param secret_key
 * @param hdrdate
 * @param hdrregion
 * @param hdrservice
 * @return std::optional<std::vector<uint8_t>> the signing key, or nullopt on
 * error.
 */
static std::optional<std::vector<uint8_t>> generate_signing_key(const std::string& secret_key, const std::string& hdrdate, const std::string& hdrregion, const std::string& hdrservice)
{
  auto _initstr = "AWS4" + secret_key;
  std::vector<uint8_t> _init;
  // Create a vec<uint8_t> of the initial secret. The _hash() function can
  // then chain input to output more easily without excessive conversions.
  std::copy(_initstr.begin(), _initstr.end(), std::back_inserter(_init));

  // Hash each step.
  auto _datekey = _hash_by(_init, hdrdate, "SHA256");
  if (!_datekey) {
    return std::nullopt;
  }
  auto _dateregionkey = _hash_by(*_datekey, hdrregion, "SHA256");
  if (!_dateregionkey) {
    return std::nullopt;
  }
  auto _dateregionservicekey = _hash_by(*_dateregionkey, hdrservice, "SHA256");
  if (!_dateregionservicekey) {
    return std::nullopt;
  }
  auto signingkey = _hash_by(*_dateregionservicekey, "aws4_request", "SHA256");
  if (!signingkey) {
    return std::nullopt;
  }
  return signingkey;
}

/**
 * @brief Get a signing key given a secret and an authorization header. Return
 * nullopt on error.
 *
 * @param secret_key The secret key as a string.
 * @param authorization The HTTP Authorization: header.
 * @return std::optional<std::vector<uint8_t>> The signing key as a vector of
 * bytes, or nullopt on error.
 */
static std::optional<std::vector<uint8_t>> get_signing_key(const std::string secret_key, const std::string& authorization)
{
  boost::smatch m;
  if (!boost::regex_match(authorization, m, re_v4_auth)) {
    std::cerr << "no match v4" << std::endl;
    return std::nullopt;
  }
  auto hdrakid = m.str("accesskey");
  auto hdrdate = m.str("date");
  auto hdrregion = m.str("region");
  auto hdrservice = m.str("service");
  auto hdrsig = m.str("sig");

  return generate_signing_key(secret_key, hdrdate, hdrregion, hdrservice);
}

/**
 * @brief Generate an AWS v4 signature and return as an optional<string>. In
 * case of problems, return nullopt.
 *
 * @param string_to_sign The stringToSign as defined in the AWS docs.
 * @param secret_key The secret key as a string.
 * @param authorization The HTTP Authorization: header.
 * @return std::optional<std::string> The signature as a hex string, or
 * nullopt on error.
 */
static std::optional<std::string> verify_aws_v4_signature(std::string string_to_sign, std::string secret_key, std::string authorization)
{
  // std::cerr << fmt::format(FMT_STRING("get_aws_v4_hash(): string_to_sign='{}' access_key_id='{}' secret_key='{}' authorization='{}'"), string_to_sign, access_key_id, secret_key, authorization) << std::endl;

  boost::smatch m;
  if (!boost::regex_match(authorization, m, re_v4_auth)) {
    std::cerr << "no match v4" << std::endl;
    return std::nullopt;
  }
  auto hdrakid = m.str("accesskey");
  auto hdrdate = m.str("date");
  auto hdrregion = m.str("region");
  auto hdrservice = m.str("service");
  auto hdrsig = m.str("sig");

  // Step 1 is in string_to_sign.

  // Step 2.
  auto signingkey = generate_signing_key(secret_key, hdrdate, hdrregion, hdrservice);
  if (!signingkey) {
    return std::nullopt;
  }

  // Step 3.
  auto sigbytes = _hash_by(*signingkey, string_to_sign, "SHA256");
  if (!sigbytes) {
    return std::nullopt;
  }

  // Hex encode the signature.
  std::string sigstr;
  boost::algorithm::hex_lower(*sigbytes, std::back_inserter(sigstr));

  // Compare the signature to that in the header.
  if (sigstr != hdrsig) {
    std::cerr << fmt::format(FMT_STRING("signature mismatch got='{}' expected='{}'"), sigstr, hdrsig) << std::endl;
    return std::nullopt;
  }

  return std::make_optional(sigstr);
}

// Match the fields out of the V4 Authorization header.
static boost::regex re_v2_auth { "^AWS\\s(?<accesskey>[0-9a-f]+):"
                                 "(?<sig>[^ \t]+)"
                                 "$" };

/* Given the inputs, generate an AWS v4 signature and return as an
 * optional<string>. In case of problems, return nullopt.
 *
 * This is the part the authenticator normally performs.
 */
static std::optional<std::string> verify_aws_v2_signature(std::string string_to_sign, std::string secret_key, std::string authorization)
{
  // std::cerr << fmt::format(FMT_STRING("get_aws_v4_hash(): string_to_sign='{}' access_key_id='{}' secret_key='{}' authorization='{}'"), string_to_sign, access_key_id, secret_key, authorization) << std::endl;

  boost::smatch m;
  if (!boost::regex_match(authorization, m, re_v2_auth)) {
    std::cerr << "no match V2" << std::endl;
    return std::nullopt;
  }
  auto hdrakid = m.str("accesskey");
  auto hdrsig = m.str("sig");

  // Step 1 is in string_to_sign.

  // Step 2.
  auto initstr = secret_key;
  std::vector<uint8_t> signingkey;
  // Create a vec<uint8_t> of the initial secret. The _hash() function can
  // then chain input to output more easily without excessive conversions.
  std::copy(initstr.begin(), initstr.end(), std::back_inserter(signingkey));

  // Step 3.
  auto sigbytes = _hash_by(signingkey, string_to_sign, "SHA1");
  if (!sigbytes) {
    return std::nullopt;
  }

  // Hex encode the signature.
  std::string sigstr;
  std::copy((*sigbytes).begin(), (*sigbytes).end(), std::back_inserter(sigstr));
  auto sig_b64 = rgw::to_base64(sigstr);

  // Compare the signature to that in the header.
  if (sig_b64 != hdrsig) {
    std::cerr << fmt::format(FMT_STRING("signature mismatch got='{}' expected='{}'"), sig_b64, hdrsig) << std::endl;
    return std::nullopt;
  }

  return std::make_optional(sig_b64);
}

// Given an Authorization header (v2 or v4), extract and return the access key
// id. Return nullopt on any error.
static std::optional<std::string> extract_access_key_id_from_authorization_header(const std::string authorization)
{
  if (ba::starts_with(authorization, "AWS ")) {
    boost::smatch m;
    if (!boost::regex_match(authorization, m, re_v2_auth)) {
      std::cerr << "no match V2" << std::endl;
      return std::nullopt;
    }
    return std::make_optional(m.str("accesskey"));

  } else {
    boost::smatch m;
    if (!boost::regex_match(authorization, m, re_v4_auth)) {
      std::cerr << "no match v4" << std::endl;
      return std::nullopt;
    }
    return std::make_optional(m.str("accesskey"));
  }
}

// Examine the Authorization header. If it starts with 'AWS ', call the v2
// signature handler. Otherwise call the v4 handler.
static std::optional<std::string> verify_aws_signature(std::string string_to_sign, std::string secret_key, std::string authorization)
{
  if (ba::starts_with(authorization, "AWS ")) {
    return verify_aws_v2_signature(string_to_sign, secret_key, authorization);
  } else {
    return verify_aws_v4_signature(string_to_sign, secret_key, authorization);
  }
}

// Minimal client for req_state.
class TestClient : public rgw::io::BasicClient {
  RGWEnv env;

protected:
  virtual int init_env(CephContext* cct) override
  {
    return 0;
  }

public:
  virtual RGWEnv& get_env() noexcept override
  {
    return env;
  }

  virtual size_t complete_request() override
  {
    return 0;
  }
};

/* #endregion */

using namespace rgw;

// Stole this from test_rgw_lua.cc. Set up a req_state s for testing.
#define DEFINE_REQ_STATE \
  RGWProcessEnv pe;      \
  RGWEnv e;              \
  req_state s(g_ceph_context, pe, &e, 0);

/*
 * File-local framework tests.
 */

// Test the local signature implementation with known-good signature data.
TEST(HandoffMeta, SigPositive)
{
  for (const auto& t : sigpass_tests) {
    auto info = info_for_credential(t.access_key);
    ASSERT_TRUE(info) << "No secret found for " << t.access_key;
    auto s2s = rgw::from_base64(t.ss_base64);
    auto sig = verify_aws_signature(s2s, (*info).secret, t.authorization);
    ASSERT_TRUE(sig);
  }
}

TEST(HandoffMeta, SigNegative)
{
  for (const auto& t : sigpass_tests) {
    auto info = info_for_credential(t.access_key);
    ASSERT_TRUE(info) << "No secret found for " << t.access_key;
    auto s2s = rgw::from_base64(t.ss_base64);
    auto sig = verify_aws_signature("0" + s2s, (*info).secret, t.authorization);
    ASSERT_FALSE(sig);
    sig = verify_aws_signature(t.ss_base64, (*info).secret + "0", t.authorization);
    ASSERT_FALSE(sig);
  }
}

/*
 * HandoffHelper tests.
 */

TEST(HandoffHelper, Init)
{
  HandoffHelper hh;
  ASSERT_EQ(hh.init(g_ceph_context, nullptr), 0);
}

/* #region HandoffHelperImplGRPC tests */

class TestAuthImpl final : public authenticator::v1::AuthenticatorService::Service {

  DoutPrefix dpp_ { g_ceph_context, ceph_subsys_rgw, "unittest gRPC server " };

  // Save some typing. This is an enum in S3ErrorDetails.
  using s3err_type = authenticator::v1::S3ErrorDetails::Type;

  grpc::Status grpc_error(grpc::StatusCode grpc_code, s3err_type type, int http_code, const std::string& message)
  {
    // This incantation is extracted from example code found here:
    // https://github.com/grpc/grpc/blob/master/examples/cpp/error_details/greeter_server.cc,
    // referenced from the 'Richer error model' doc
    // (https://grpc.io/docs/guides/error/).
    //
    // Create an S3ErrorDetails object containing details RGW will need, and
    // pack it into a grpc::Status object returnable by this method.

    authenticator::v1::S3ErrorDetails err;
    err.set_type(type);
    // err.set_http_code(http_code);
    // err.set_message(message);
    authenticator::v1::S3ErrorDetails s3errordetails;
    s3errordetails.set_type(type);
    s3errordetails.set_http_status_code(http_code);

    ::google::rpc::Status s;
    s.set_code(grpc_code);
    s.set_message(message);
    s.add_details()->PackFrom(s3errordetails);
    return grpc::Status { grpc_code, message, s.SerializeAsString() };
  }

  // Very simple implementation of the auth service. XXX Isn't as careful with
  // return codes as it could be, and returns no authorization-related codes
  // for authenticated requests. For anonymous requests, will return success
  // for bucket 'public' and failure for any other bucket.
  grpc::Status AuthenticateREST(grpc::ServerContext* context, const authenticator::v1::AuthenticateRESTRequest* request, authenticator::v1::AuthenticateRESTResponse* response) override
  {
    ldpp_dout(&dpp_, 20) << __func__ << ": enter" << dendl;

    // Just a debug note.
    if (request->skip_timestamp_validation() == true) {
      ldpp_dout(&dpp_, 1) << __func__
                          << ": NOTE: skip_timestamp_validation is set"
                          << dendl;
    }

    // Check for an anonymous request.
    if (request->authorization_header().empty()) {
      if (request->has_bucket_name() && request->bucket_name() == "public") {
        ldpp_dout(&dpp_, 20) << __func__ << ": exit OK (ANONYMOUS)" << dendl;
        return grpc::Status::OK;
      }
      ldpp_dout(&dpp_, 20) << __func__ << ": exit UNAUTHENTICATED (ANONYMOUS)"
                           << dendl;
      return grpc_error(grpc::StatusCode::PERMISSION_DENIED,
          s3err_type::S3ErrorDetails_Type_TYPE_ACCESS_DENIED, 403,
          "anonymous access denied");
    }

    auto maybe_akid = extract_access_key_id_from_authorization_header(request->authorization_header());
    if (!maybe_akid) {
      ldpp_dout(&dpp_, 20) << __func__ << ": unable to extract access key from authorization header" << dendl;
      return grpc_error(grpc::StatusCode::INVALID_ARGUMENT, s3err_type::S3ErrorDetails_Type_TYPE_AUTHORIZATION_HEADER_MALFORMED, 400, "unable to extract access key from authorization header");
    }
    auto access_key_id = *maybe_akid;

    // Use our pre-canned authentication database.
    auto info = info_for_credential(access_key_id);
    if (!info) {
      ldpp_dout(&dpp_, 20) << __func__ << ": exit CREDENTIALS NOT FOUND" << dendl;
      return grpc_error(grpc::StatusCode::UNAUTHENTICATED, s3err_type::S3ErrorDetails_Type_TYPE_INVALID_ACCESS_KEY_ID, 403, "credentials not found");
    }
    auto sig = verify_aws_signature(request->string_to_sign(),
        info->secret,
        request->authorization_header());
    if (!sig) {
      ldpp_dout(&dpp_, 20) << __func__ << ": exit SIGNATURE MISMATCH" << dendl;
      return grpc_error(grpc::StatusCode::UNAUTHENTICATED, s3err_type::S3ErrorDetails_Type_TYPE_SIGNATURE_DOES_NOT_MATCH, 403, "signature mismatch");
    }
    response->set_canonical_user_id(info->userid);
    // Set the other Authenticator response fields so we can check for them
    // later. They're needed by the Authorizer.
    response->set_user_arn(info->userid + "_user_arn");
    response->set_assuming_user_arn(info->userid + "_assuming_user_arn");
    response->set_account_arn(info->userid + "_account_arn");
    response->set_role_arn(info->userid + "_role_arn");

    ldpp_dout(&dpp_, 20) << __func__ << ": exit OK" << dendl;
    return grpc::Status::OK;
  }

  // Simple implementation of the GetSigningKey service.
  grpc::Status GetSigningKey(grpc::ServerContext* context, const authenticator::v1::GetSigningKeyRequest* request, authenticator::v1::GetSigningKeyResponse* response) override
  {
    ldpp_dout(&dpp_, 20) << __func__ << ": enter" << dendl;
    ldpp_dout(&dpp_, 0) << __func__ << ": XXX auth: " << request->authorization_header() << dendl;

    auto maybe_akid = extract_access_key_id_from_authorization_header(request->authorization_header());
    if (!maybe_akid) {
      ldpp_dout(&dpp_, 20) << __func__ << ": unable to extract access key from authorization header" << dendl;
      return grpc_error(grpc::StatusCode::INVALID_ARGUMENT, s3err_type::S3ErrorDetails_Type_TYPE_AUTHORIZATION_HEADER_MALFORMED, 400, "unable to extract access key from authorization header");
    }
    auto access_key_id = *maybe_akid;

    // Use our pre-canned authentication database.
    auto info = info_for_credential(access_key_id);
    if (!info) {
      ldpp_dout(&dpp_, 20) << __func__ << ": credentials not found" << dendl;
      return grpc_error(grpc::StatusCode::UNAUTHENTICATED, s3err_type::S3ErrorDetails_Type_TYPE_INVALID_ACCESS_KEY_ID, 403, "credentials not found");
    }

    auto signing_key = get_signing_key(info->secret, request->authorization_header());
    if (!signing_key) {
      ldpp_dout(&dpp_, 20) << __func__ << ": failed to generate signing key" << dendl;
      // Not sure what else could cause this to fail.
      return grpc_error(grpc::StatusCode::UNAUTHENTICATED, s3err_type::S3ErrorDetails_Type_TYPE_INVALID_ACCESS_KEY_ID, 403, "credentials not found");
    }
    response->set_signing_key(signing_key->data(), signing_key->size());
    ldpp_dout(&dpp_, 20) << __func__ << ": exit OK" << dendl;
    return grpc::Status::OK;
  }
};

/**
 * @brief gRPC mode HandoffHelperImpl end-to-end test fixture.
 *
 * Use GRPCTestServer to implement the gRPC server on a random port, then
 * configure the HandoffHelperImpl to use it. The tests then issue gRPC()
 * calls against the helper.
 *
 * You *MUST* call helper_init() if you're going to use the HandoffHelperImpl
 * at all! Otherwise the channel and store won't be set up. This isn't called
 * automatically because sometimes we want to modify the channel configuration
 * first.
 *
 * It also doesn't implicitly start the server, you have to call start_test().
 * This is so we can easily test behaviour when the server isn't started.
 *
 * This actual-server approach has the virtue of being a somewhat faithful
 * client-side test. The server side is rather simplistic, obviously; but
 * that's probably ok.
 *
 * The fixture _will_ call server().stop() in TearDown, that feels relatively
 * safe.
 */
class HandoffHelperImplGRPCTest : public ::testing::Test {

protected:
  HandoffHelperImpl hh_;
  optional_yield y_ = null_yield;
  DoutPrefix dpp_ { g_ceph_context, ceph_subsys_rgw, "unittest " };

  // This manages the test gRPC server.
  GRPCTestServer<TestAuthImpl> server_;

  // Don't start the server - some tests might want a chance to see what
  // happens without a server.
  void SetUp() override
  {
  }

  void helper_init()
  {
    dpp_.get_cct()->_conf.set_val_or_die("rgw_handoff_enable_grpc", "true");
    dpp_.get_cct()->_conf.apply_changes(nullptr);
    ASSERT_EQ(dpp_.get_cct()->_conf->rgw_handoff_enable_grpc, true);
    // Note init() can take the server address URI, it's normally defaulted to
    // empty which means 'use the Ceph configuration'.
    ASSERT_EQ(hh_.init(g_ceph_context, nullptr, server_.address()), 0);
  }

  // Will stop the server. There's no situation where we want it left around.
  void TearDown() override
  {
    server().stop();
  }

  /// Return the gRPC server manager instance.
  GRPCTestServer<TestAuthImpl>& server() { return server_; }
};

// This just tests we can instantiate the test classes.
TEST_F(HandoffHelperImplGRPCTest, Null)
{
}

// Make sure server().start() is idempotent.
TEST_F(HandoffHelperImplGRPCTest, MetaStart)
{
  server().start();
  for (int n = 0; n < 1000; n++) {
    server().start();
  }
  server().stop();
}

// Make sure server().stop() is idempotent.
TEST_F(HandoffHelperImplGRPCTest, MetaStop)
{
  server().start();
  for (int n = 0; n < 1000; n++) {
    server().stop();
  }
}

// Fail properly when the Authorization header is absent and one can't be
// synthesized.
TEST_F(HandoffHelperImplGRPCTest, FailIfMissingAuthorizationHeader)
{
  helper_init();
  TestClient cio;

  auto t = sigpass_tests[0];
  DEFINE_REQ_STATE;
  s.cio = &cio;
  auto string_to_sign = rgw::from_base64(t.ss_base64);
  auto res = hh_.auth(&dpp_, "", t.access_key, string_to_sign, t.signature, &s, y_);
  ASSERT_EQ(res.code(), EACCES);
  ASSERT_THAT(res.message(), testing::ContainsRegex("missing Authorization"));
}

TEST_F(HandoffHelperImplGRPCTest, AnonymousExpectedSuccess)
{
  server().start();
  helper_init();
  TestClient cio;

  DEFINE_REQ_STATE;
  s.cio = &cio;

  // Set up the request so it has a method and a bucket. This will allow the
  // test gRPC server to return success for the 'public' bucket and failure
  // for anything else.
  s.info.method = "GET";
  s.relative_uri = s.decoded_uri = "/public/foo/bar"; // Bucket 'public', key 'foo/bar'.

  auto res = hh_.anonymous_authorize(&dpp_, &s, y_);
  ASSERT_TRUE(res.is_ok()) << fmt::format(
      FMT_STRING("Expected success, got: {}"), res.message());
}

TEST_F(HandoffHelperImplGRPCTest, AnonymousExpectedFail)
{
  server().start();
  helper_init();
  TestClient cio;

  DEFINE_REQ_STATE;
  s.cio = &cio;

  // Set up the request so it has a method and a bucket. This will allow the
  // test gRPC server to return success for the 'public' bucket and failure
  // for anything else.
  s.info.method = "GET";
  s.relative_uri = s.decoded_uri = "/private/foo/bar"; // Bucket 'private', key 'foo/bar'.

  auto res = hh_.anonymous_authorize(&dpp_, &s, y_);
  ASSERT_TRUE(res.is_err())
      << fmt::format(FMT_STRING("Expected failure, got: {}"), res.message());
}

TEST_F(HandoffHelperImplGRPCTest, SignatureV2CanBeDisabled)
{
  // // XXX I can't get the configuration observer to work in the harness.
  // // Luckily there are methods on the helperimpl that I can call directly.

  server().start();
  helper_init();

  auto t = v2_sample;

  TestClient cio;
  // Set headers in the cio's env, not rgw_env (below).
  cio.get_env().set("HTTP_AUTHORIZATION", t.authorization);
  ldpp_dout(&dpp_, 20) << fmt::format(FMT_STRING("Auth: {}"), t.authorization) << dendl;

  DEFINE_REQ_STATE;
  s.cio = &cio;
  auto string_to_sign = rgw::from_base64(t.ss_base64);
  // This is what the config observer would call.
  hh_.set_signature_v2(dpp_.get_cct(), true);
  auto res = hh_.auth(&dpp_, "", t.access_key, string_to_sign, t.signature, &s, y_);
  EXPECT_TRUE(res.is_ok());

  // dpp_.get_cct()->_conf->rgw_handoff_enable_signature_v2 = false;
  // dpp_.get_cct()->_conf.apply_changes(nullptr);
  hh_.set_signature_v2(dpp_.get_cct(), false);
  res = hh_.auth(&dpp_, "", t.access_key, string_to_sign, t.signature, &s, y_);
  EXPECT_TRUE(res.is_err());

  // dpp_.get_cct()->_conf->rgw_handoff_enable_signature_v2 = true;
  // dpp_.get_cct()->_conf.apply_changes(nullptr);
  hh_.set_signature_v2(dpp_.get_cct(), true);
  res = hh_.auth(&dpp_, "", t.access_key, string_to_sign, t.signature, &s, y_);
  EXPECT_TRUE(res.is_ok());
}

// Test working signatures with the verify_by_func handler above.
TEST_F(HandoffHelperImplGRPCTest, HeaderHappyPath)
{
  server().start();
  helper_init();

  for (const auto& t : sigpass_tests) {
    TestClient cio;
    // Set headers in the cio's env, not rgw_env (below).
    cio.get_env().set("HTTP_AUTHORIZATION", t.authorization);
    ldpp_dout(&dpp_, 20) << fmt::format(FMT_STRING("Auth: {}"), t.authorization) << dendl;

    DEFINE_REQ_STATE;
    s.cio = &cio;
    s.handoff_authz = std::make_unique<HandoffAuthzState>(true);
    auto string_to_sign = rgw::from_base64(t.ss_base64);
    auto res = hh_.auth(&dpp_, "", t.access_key, string_to_sign, t.signature, &s, y_);
    EXPECT_TRUE(res.is_ok()) << "should pass test '" << t.name << "'";

    // Check we captured the fields that the Authorizer will require later.
    auto userid_base = res.userid();
    auto info = info_for_credential(t.access_key);
    ASSERT_THAT(info, testing::Ne(std::nullopt));
    ASSERT_EQ(userid_base, info->userid);
    ASSERT_EQ(s.handoff_authz->canonical_user_id(), userid_base);
    ASSERT_EQ(s.handoff_authz->user_arn(), userid_base + "_user_arn");
    ASSERT_EQ(s.handoff_authz->assuming_user_arn(), userid_base + "_assuming_user_arn");
    ASSERT_EQ(s.handoff_authz->account_arn(), userid_base + "_account_arn");
    ASSERT_EQ(s.handoff_authz->role_arn(), userid_base + "_role_arn");
  }
}

// Test deliberately broken signatures with the verify_by_func handler above.
TEST_F(HandoffHelperImplGRPCTest, HeaderExpectBadSignature)
{
  server().start();
  helper_init();

  for (const auto& t : sigfail_tests) {
    TestClient cio;
    // Set headers in the cio's env, not rgw_env (below).
    cio.get_env().set("HTTP_AUTHORIZATION", t.authorization);
    ldpp_dout(&dpp_, 20) << fmt::format(FMT_STRING("Auth: {}"), t.authorization) << dendl;

    DEFINE_REQ_STATE;
    s.cio = &cio;
    auto string_to_sign = rgw::from_base64(t.ss_base64);
    auto res = hh_.auth(&dpp_, "", t.access_key, string_to_sign, t.signature, &s, y_);
    EXPECT_FALSE(res.is_ok()) << "should fail test '" << t.name << "'";
  }
}

// This is hardcoded in the library, you can't configure a reconnect delay
// less than 100ms. (grpc src/core/ext/filters/client_channel/subchannel.cc
// function ParseArgsForBackoffValues().) This allows five more milliseconds.
//
constexpr int SMALLEST_RECONNECT_DELAY_MS = 105;

// Check the system doesn't fail if started with a non-functional auth server.
TEST_F(HandoffHelperImplGRPCTest, ChannelRecoversFromDeadAtStartup)
{
  ceph_assert(g_ceph_context != nullptr);

  // We *don't* want to use get_authn_channel().get_default_channel_args()
  // here - that will set the channel arguments to the values in
  // configuration, which isn't helpful. Further, it will also make it very
  // difficult to change those configured arguments because of the way
  // ChannelArguments works. Better to just set the values we care about in an
  // empty object.
  //
  // To explain further: grpc::ChannelArguments encapsulates a list of
  // arguments. It's not a map, so setting the same key more than once will
  // set that key more than once in the ChannelArguments object. Not only is
  // this wasteful, but it's apparently not predictable which one of the
  // multiple instances of the key will be used. It's safer to just not set
  // the key more than once.

  auto args = grpc::ChannelArguments();
  args.SetInt(GRPC_ARG_INITIAL_RECONNECT_BACKOFF_MS, 1);
  args.SetInt(GRPC_ARG_MIN_RECONNECT_BACKOFF_MS, 1);
  args.SetInt(GRPC_ARG_MAX_RECONNECT_BACKOFF_MS, 1);
  hh_.get_authn_channel().set_channel_args(dpp_.get_cct(), args);

  helper_init();
  TestClient cio;

  auto t = sigpass_tests[0];
  cio.get_env().set("HTTP_AUTHORIZATION", t.authorization);
  DEFINE_REQ_STATE;
  s.cio = &cio;
  auto string_to_sign = rgw::from_base64(t.ss_base64);
  auto res = hh_.auth(&dpp_, "", t.access_key, string_to_sign, t.signature, &s, y_);
  ASSERT_FALSE(res.is_ok()) << "should fail";
  ASSERT_EQ(res.code(), EACCES) << "should return EACCES";
  ASSERT_EQ(res.err_type(), HandoffAuthResult::error_type::TRANSPORT_ERROR) << "should return TRANSPORT_ERROR";

  server().start();
  // Wait as short a time as the library allows, plus a few millisecond.
  std::this_thread::sleep_for(std::chrono::milliseconds(SMALLEST_RECONNECT_DELAY_MS));
  res = hh_.auth(&dpp_, "", t.access_key, string_to_sign, t.signature, &s, y_);
  EXPECT_TRUE(res.is_ok()) << "should now succeed";
  EXPECT_EQ(res.err_type(), HandoffAuthResult::error_type::NO_ERROR) << "should now show no error";
}

TEST_F(HandoffHelperImplGRPCTest, GetSigningKey)
{
  server().start();
  helper_init();
  TestClient cio;

  for (const auto& t : sk_pass) {
    cio.get_env().set("HTTP_AUTHORIZATION", t.header);
    DEFINE_REQ_STATE;
    s.cio = &cio;
    auto sk = hh_.get_signing_key(&dpp_, t.header, &s, y_);
    EXPECT_TRUE(sk.has_value());
    if (sk.has_value()) {
      std::string sk_hex;
      boost::algorithm::hex_lower(sk->cbegin(), sk->cend(), std::back_inserter(sk_hex));
      EXPECT_EQ(sk_hex, t.signing_key_hex) << fmt::format(FMT_STRING("test {}: expect match"), t.name);
    }
  }
}

/* #endregion HandoffHelperImplGRPC tests */

/* #region PresignedTestData */

struct HandoffHeaderSynthData {
  std::string name;
  std::string url;
  std::string header;
};

static HandoffHeaderSynthData synth_pass[] = {
  // All use credential 0555b35654ad1656d804, the RGW test user.

  // `aws --endpoint-url='http://amygdala-ub01.home.ae-35.com:8000' s3 presign
  // s3://testnv/rand --expires 3600`. No region.
  {
      "aws s3 GET no region",
      "http://amygdala-ub01.home.ae-35.com:8000/testnv/rand?AWSAccessKeyId=0555b35654ad1656d804&Signature=XukLh8ZYkh7LhfDNGGPEznT5qMk%3D&Expires=1697103292",
      "AWS 0555b35654ad1656d804:XukLh8ZYkh7LhfDNGGPEznT5qMk=",
  },
  // `aws --endpoint-url='http://amygdala-ub01.home.ae-35.com:8000' s3 presign
  // s3://testnv/rand --expires 3600 --region eu-west-2`. Non-default region.
  {
      "aws s3 GET with region",
      "http://amygdala-ub01.home.ae-35.com:8000/testnv/rand?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=0555b35654ad1656d804%2F20231012%2Feu-west-2%2Fs3%2Faws4_request&X-Amz-Date=20231012T083736Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=d63f2167860f1f3a02b098988cbe9e7cf19e2d3208044e70d52bcc88985abb17",
      "AWS4-HMAC-SHA256 Credential=0555b35654ad1656d804/20231012/eu-west-2/s3/aws4_request, SignedHeaders=host, Signature=d63f2167860f1f3a02b098988cbe9e7cf19e2d3208044e70d52bcc88985abb17",
  },
  // `s3cmd --host http://amygdala-ub01.home.ae-35.com:8000 signurl
  // s3://testnv/rand +3600`. No region. No --host-bucket set.
  {
      "s3cmd signurl GET no region",
      "http://amygdala-ub01.home.ae-35.com:8000/testnv/rand?AWSAccessKeyId=0555b35654ad1656d804&Expires=1697103824&Signature=2X2H46QEM73dL8EAHiWTgpEUYqs%3D",
      "AWS 0555b35654ad1656d804:2X2H46QEM73dL8EAHiWTgpEUYqs=",
  },
  // `s3cmd --host http://amygdala-ub01.home.ae-35.com:8000 --region eu-west-2
  // signurl s3://testnv/rand +3600`. Non-default region. No --host-bucket
  // set. Note s3cmd didn't switch to the 'v4-ish' presigned URL format.
  {
      "s3cmd signurl GET with region",
      "http://amygdala-ub01.home.ae-35.com:8000/testnv/rand?AWSAccessKeyId=0555b35654ad1656d804&Expires=1697110701&Signature=1QoTXjLEU3oh0LTfRn5wrccgWWw%3D",
      "AWS 0555b35654ad1656d804:1QoTXjLEU3oh0LTfRn5wrccgWWw=" },
  // `presigned_url.py --endpoint http://amygdala-ub01.home.ae-35.com:8000 testnv rand get --expiry 3600`. No region.
  {
      "presigned_url.py GET no region",
      "http://amygdala-ub01.home.ae-35.com:8000/testnv/rand?AWSAccessKeyId=0555b35654ad1656d804&Signature=EqiVBEaa%2B9wUIpHUw26ph74Pq4o%3D&Expires=1697110900",
      "AWS 0555b35654ad1656d804:EqiVBEaa+9wUIpHUw26ph74Pq4o=",
  },

  // `presigned_url.py --endpoint http://amygdala-ub01.home.ae-35.com:8000
  // testnv rand get --expiry 3600 --region eu-west-2`. Non-default region.
  {
      "presigned_url.py GET with region",
      "http://amygdala-ub01.home.ae-35.com:8000/testnv/rand?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=0555b35654ad1656d804%2F20231012%2Feu-west-2%2Fs3%2Faws4_request&X-Amz-Date=20231012T104359Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=a54b4ae7a782c395ef8a75a0fbaf23f6d4a8e6d52d06cdc358be03344dd439b4",
      "AWS4-HMAC-SHA256 Credential=0555b35654ad1656d804/20231012/eu-west-2/s3/aws4_request, SignedHeaders=host, Signature=a54b4ae7a782c395ef8a75a0fbaf23f6d4a8e6d52d06cdc358be03344dd439b4",
  },
  // `presigned_url.py --endpoint http://amygdala-ub01.home.ae-35.com:8000
  // testnv rand put --expiry 3600`. No region.
  {
      "presigned_url.py PUT no region",
      "http://amygdala-ub01.home.ae-35.com:8000/testnv/rand?AWSAccessKeyId=0555b35654ad1656d804&Signature=ob%2FzEMUCnhQyX1KE6vhGo0oSZq4%3D&Expires=1697107623",
      "AWS 0555b35654ad1656d804:ob/zEMUCnhQyX1KE6vhGo0oSZq4=",
  },
  // `presigned_url.py --endpoint http://amygdala-ub01.home.ae-35.com:8000
  // testnv rand put --expiry 3600 --region eu-west-2`. Non-default region.
  {
      "presigned_url.py PUT with region",
      "http://amygdala-ub01.home.ae-35.com:8000/testnv/rand?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=0555b35654ad1656d804%2F20231012%2Feu-west-2%2Fs3%2Faws4_request&X-Amz-Date=20231012T094852Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=cd8ed8099f8349c43bf1804bf3780ab0885e7c94baffcce65aacd34b4e6b6ade",
      "AWS4-HMAC-SHA256 Credential=0555b35654ad1656d804/20231012/eu-west-2/s3/aws4_request, SignedHeaders=host, Signature=cd8ed8099f8349c43bf1804bf3780ab0885e7c94baffcce65aacd34b4e6b6ade",
  }
};

/* #endregion */

/**
 * @brief HandoffHelperImpl test fixture. Not for end-to-end tests!
 */
class HandoffHelperImplSubsysTest : public ::testing::Test {
protected:
  void SetUp() override
  {
    // dpp.get_cct()->_conf.set_val_or_die("rgw_handoff_enable_grpc", "false");
    // dpp.get_cct()->_conf.apply_changes(nullptr);
    ASSERT_EQ(dpp.get_cct()->_conf->rgw_handoff_enable_grpc, true);
    ASSERT_EQ(hh.init(g_ceph_context, nullptr), 0);
  }

  bool grpc_enabled;
  HandoffHelperImpl hh;
  optional_yield y = null_yield;
  DoutPrefix dpp { g_ceph_context, ceph_subsys_rgw, "unittest " };
};

// Make sure we're properly creating the Authorization: header from query
// parameters. This is order-dependent; however every program I've tried it
// with (s3cmd, aws s3 presign, the AWS presigned_url.py SDK example code)
// respects this order.
TEST_F(HandoffHelperImplSubsysTest, PresignedSynthesizeHeader)
{
  for (auto const& t : synth_pass) {

    // We need a req_state struct to pass to synthesize_auth_header(), so
    // implement the pieces of RGWHandler_REST_S3::init_from_header() that we
    // care about, taking the test URL as input.
    DEFINE_REQ_STATE;
    // In the input URL, skip to the '?' marking the start of URL parameters.
    // (This is what init_from_header() does.)
    auto p = t.url.c_str();
    for (auto c : t.url) {
      if (c == '?') {
        break;
      }
      p++;
    }
    ASSERT_TRUE(*p != 0) << t.name;
    // Parse arguments from the URL.
    s.info.args.set(p);
    s.info.args.parse(&s);
    // End init_from_header() mock.

    auto got = hh.synthesize_auth_header(&dpp, &s);
    ASSERT_TRUE(got.has_value()) << t.name;
    EXPECT_EQ(*got, t.header) << t.name;
  }
}

/* #region HandoffConfigObserver */

/**
 * @brief Mock enough of HandoffGRPCChannel's interface to get
 * HandoffConfigObserver<MockHelperForConfigObserver> to compile. At the time
 * of writing this means get_default_channel_args(), set_channel_args() and
 * set_channel_uri().
 */
class MockHandoffGRPCChannel {
public:
  bool channel_args_set_ = false;
  std::string channel_uri_;

  grpc::ChannelArguments get_default_channel_args(CephContext* const cct)
  {
    return grpc::ChannelArguments();
  }
  void set_channel_args(CephContext* const cct, const grpc::ChannelArguments& args) { channel_args_set_ = true; }
  void set_channel_uri(CephContext* const cct, const std::string& uri) { channel_uri_ = uri; }
}; // class MockHandoffGRPCChannel

/**
 * @brief Mock the chunks of HandoffHelperImpl we need to check that the
 * config observer is working properly.
 *
 * See the notes on HandoffConfigObserver<T> for more details. This class
 * allows us to instantiate a config observer and make sure it's responding
 * correctly to configuration changes.
 */
class MockHelperForConfigObserver final {
public:
  MockHelperForConfigObserver()
      : observer_(*this)
  {
  }
  ~MockHelperForConfigObserver() = default;

  int init(CephContext* const cct)
  {
    return 0;
  }

  MockHandoffGRPCChannel& get_authn_channel() { return authn_channel_; }
  MockHandoffGRPCChannel& get_authz_channel() { return authz_channel_; }

  void set_signature_v2(CephContext* const cct, bool enable) { signature_v2_ = enable; }
  void set_anonymous_authorization(CephContext* const cct, bool enable) { anonymous_authorization_ = enable; }
  void set_chunked_upload_mode(CephContext* const cct, bool enable) { chunked_upload_ = enable; }
  void set_authorization_mode(CephContext* const cct, AuthParamMode mode) { authparam_mode_ = mode; }

public:
  HandoffConfigObserver<MockHelperForConfigObserver> observer_;
  AuthParamMode authparam_mode_;
  MockHandoffGRPCChannel authn_channel_;
  MockHandoffGRPCChannel authz_channel_;
  bool signature_v2_;
  bool chunked_upload_;
  bool anonymous_authorization_;
};

/**
 * @brief Test that the config observer is hooked up properly for runtime
 * changes to variables we care about.
 */
class TestHandoffConfigObserver : public ::testing::Test {

protected:
  void SetUp() override
  {
    ASSERT_EQ(dpp_.get_cct()->_conf->rgw_handoff_enable_grpc, true);
    ASSERT_EQ(hh_.init(g_ceph_context), 0);
  }

  MockHelperForConfigObserver hh_;
  DoutPrefix dpp_ { g_ceph_context, ceph_subsys_rgw, "unittest " };
};

TEST_F(TestHandoffConfigObserver, Null)
{
}

TEST_F(TestHandoffConfigObserver, SignatureV2Mode)
{
  // Parameters we'll 'change'.
  std::set<std::string> changed { "rgw_handoff_enable_signature_v2" };

  auto cct = dpp_.get_cct();
  auto conf = cct->_conf;

  conf->rgw_handoff_enable_signature_v2 = true;
  hh_.observer_.handle_conf_change(conf, changed);
  EXPECT_EQ(hh_.signature_v2_, true);

  conf->rgw_handoff_enable_signature_v2 = false;
  hh_.observer_.handle_conf_change(conf, changed);
  EXPECT_EQ(hh_.signature_v2_, false);
}

TEST_F(TestHandoffConfigObserver, ChunkedUploadMode)
{
  // Parameters we'll 'change'.
  std::set<std::string> changed { "rgw_handoff_enable_chunked_upload" };

  auto cct = dpp_.get_cct();
  auto conf = cct->_conf;

  conf->rgw_handoff_enable_chunked_upload = true;
  hh_.observer_.handle_conf_change(conf, changed);
  EXPECT_EQ(hh_.chunked_upload_, true);

  conf->rgw_handoff_enable_chunked_upload = false;
  hh_.observer_.handle_conf_change(conf, changed);
  EXPECT_EQ(hh_.chunked_upload_, false);
}

TEST_F(TestHandoffConfigObserver, AnonymousAuthorizationMode)
{
  // Parameters we'll 'change'.
  std::set<std::string> changed { "rgw_handoff_enable_anonymous_authorization" };

  auto cct = dpp_.get_cct();
  auto conf = cct->_conf;

  conf->rgw_handoff_enable_anonymous_authorization = true;
  hh_.observer_.handle_conf_change(conf, changed);
  EXPECT_EQ(hh_.anonymous_authorization_, true);

  conf->rgw_handoff_enable_anonymous_authorization = false;
  hh_.observer_.handle_conf_change(conf, changed);
  EXPECT_EQ(hh_.anonymous_authorization_, false);
}

// Test that the config change propagates to the helper. We're not parsing the
// individual arg setting, that would mean essentially recreating the helper's
// code in the mock which is pointless.
//
// In all the test cases we'll call handle_conf_change() directly. I had
// problems getting the observer to work reliably in unit tests, whether I
// just relied on 'automatic' change application, or if I directly called
// conf.apply_changes(). It doesn't really matter - what we're testing here is
// that if handle_conf_change() is called properly, then the configuration
// will flow through to the helperimpl.
//
TEST_F(TestHandoffConfigObserver, GRPCChannelArgs)
{
  // Parameters we'll 'change'.
  std::set<std::string> changed;

  std::set<std::string> param = {
    "rgw_handoff_grpc_arg_initial_reconnect_backoff_ms",
    "rgw_handoff_grpc_arg_min_reconnect_backoff_ms",
    "rgw_handoff_grpc_arg_max_reconnect_backoff_ms"
  };

  auto cct = dpp_.get_cct();
  auto conf = cct->_conf;

  for (const auto& p : param) {
    hh_.authn_channel_.channel_args_set_ = false;

    conf.set_val_or_die(p, "1001");
    changed.clear();
    changed.emplace(p);
    hh_.observer_.handle_conf_change(conf, changed);
    ASSERT_TRUE(hh_.authn_channel_.channel_args_set_);
  }
}

TEST_F(TestHandoffConfigObserver, GRPCURI)
{
  // Parameters we'll 'change'.
  std::set<std::string> changed { "rgw_handoff_grpc_uri" };

  auto cct = dpp_.get_cct();
  auto conf = cct->_conf;

  conf->rgw_handoff_grpc_uri = "foo";
  hh_.observer_.handle_conf_change(conf, changed);
  ASSERT_EQ(hh_.authn_channel_.channel_uri_, "foo");
}

TEST_F(TestHandoffConfigObserver, AuthParamMode)
{
  // Parameters we'll 'change'.
  std::set<std::string> changed { "rgw_handoff_authparam_always", "rgw_handoff_authparam_withtoken" };

  auto cct = dpp_.get_cct();
  auto conf = cct->_conf;

  // Default -> 'ALWAYS'.
  conf->rgw_handoff_authparam_always = true;
  conf->rgw_handoff_authparam_withtoken = false;
  hh_.observer_.handle_conf_change(conf, changed);
  // hh_.set_authorization_mode(cct, hh_.observer_.get_authorization_mode(conf));
  EXPECT_EQ(hh_.observer_.get_authorization_mode(conf), AuthParamMode::ALWAYS);

  // Both set -> 'ALWAYS'.
  conf->rgw_handoff_authparam_always = true;
  conf->rgw_handoff_authparam_withtoken = true;
  hh_.observer_.handle_conf_change(conf, changed);
  // hh_.set_authorization_mode(cct, hh_.observer_.get_authorization_mode(conf));
  EXPECT_EQ(hh_.observer_.get_authorization_mode(conf), AuthParamMode::ALWAYS);

  // Partial -> 'WITHTOKEN'.
  conf->rgw_handoff_authparam_always = false;
  conf->rgw_handoff_authparam_withtoken = true;
  hh_.observer_.handle_conf_change(conf, changed);
  // hh_.set_authorization_mode(cct, hh_.observer_.get_authorization_mode(conf));
  EXPECT_EQ(hh_.observer_.get_authorization_mode(conf), AuthParamMode::WITHTOKEN);

  // Never -> 'NEVER'.
  conf->rgw_handoff_authparam_always = false;
  conf->rgw_handoff_authparam_withtoken = false;
  hh_.observer_.handle_conf_change(conf, changed);
  // hh_.set_authorization_mode(cct, hh_.observer_.get_authorization_mode(conf));
  EXPECT_EQ(hh_.observer_.get_authorization_mode(conf), AuthParamMode::NEVER);
}

/* #endregion HandoffConfigObserver */

/* #region PresignedExpiryData */

struct PresignedExpiryData {
  std::string name;
  std::string url;
  time_t now;
  time_t delta;
};

static PresignedExpiryData expiry_unit[] = {
  {
      // Basic GET, v2 syntax (no region).
      // `s3cmd --host http://amygdala.home.ae-35.com:8000 signurl s3://testnv/rand +60`
      "s3cmd signurl +60",
      "http://amygdala-ub01.home.ae-35.com:8000/testnv/rand?AWSAccessKeyId=0555b35654ad1656d804&Expires=1697122817&Signature=2HxhmxDYl0WgfktL0L62GVC%2B9vY%3D",
      1697122757,
      60,
  },
  {
      // Basic GET, v4 syntax (region).
      // `aws --endpoint-url=http://amygdala.home.ae-35.com:8000 s3 presign
      // s3://testnv/rand --expires 60 --region eu-west-2`
      "aws s3 presign +60 region",
      "http://amygdala.home.ae-35.com:8000/testnv/rand?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=0555b35654ad1656d804%2F20231012%2Feu-west-2%2Fs3%2Faws4_request&X-Amz-Date=20231012T153745Z&X-Amz-Expires=60&X-Amz-SignedHeaders=host&X-Amz-Signature=050fcdc4e6f7046776b36a869ad428c68ffb7dbba807af18f146ca3923b21e2f",
      1697125065,
      60,
  }
};

/* #endregion */

// Presigned headers have an expiry time. If we're past that time, we
// shouldn't even pass the request to the Authenticator.
TEST_F(HandoffHelperImplSubsysTest, PresignedCheckExpiry)
{
  for (auto const& t : expiry_unit) {

    // We need a req_state struct to pass to synthesize_auth_header(), so
    // implement the pieces of RGWHandler_REST_S3::init_from_header() that we
    // care about, taking the test URL as input.
    DEFINE_REQ_STATE;
    // In the input URL, skip to the '?' marking the start of URL parameters.
    // (This is what init_from_header() does.)
    auto p = t.url.c_str();
    for (auto c : t.url) {
      if (c == '?') {
        break;
      }
      p++;
    }
    ASSERT_TRUE(*p != 0) << t.name;
    // Parse arguments from the URL.
    s.info.args.set(p);
    s.info.args.parse(&s);
    // End init_from_header() mock.

    auto actual = hh.valid_presigned_time(&dpp, &s, t.now);
    EXPECT_EQ(actual, true) << t.name << ": expect pass (t==now)";
    actual = hh.valid_presigned_time(&dpp, &s, t.now + t.delta);
    EXPECT_EQ(actual, true) << t.name << ": expect pass (t==now+delta)";
    actual = hh.valid_presigned_time(&dpp, &s, t.now + t.delta + 1);
    EXPECT_EQ(actual, false) << t.name << ": expect fail (t==now+delta+1)";
  }
}

/* #region AuthorizationParametersTestData */

struct AuthorizationConstructTest {
  std::string method;
  // Note that the r_uri is used as s->relative_uri. We don't have to worry
  // about URL encoding of the bucket and keys. Why? In
  // RGWREST::get_handler(), we do RGWREST::preprocess() which fills in
  // s->decoded_uri, and immediately s->decoded_uri is used to initialise the
  // RGWRestMgr, whose out parameter is s->relative_uri.
  //
  std::string r_uri;
  bool expected_pass;
  std::string exp_method;
  std::string exp_bucket;
  std::string exp_object_key;
};

static AuthorizationConstructTest eak_unit[] = {
  // Simple get.
  { "GET", "/bucket/key", true, "GET", "bucket", "key" },
  // Simple put.
  { "PUT", "/bucket/key", true, "PUT", "bucket", "key" },
  // Get with non-ASCII7 key. Essentially a no-op because we get the URL
  // post-decoding.
  { "GET", "/foo/Dj vu", true, "GET", "foo", "Dj vu" },
  // Get for ls (i.e. no key).
  { "GET", "/bucket", true, "GET", "bucket", "" },
  // Broken: No method.
  { "", "/bucket", false, "", "", "" },
  // Broken: No bucket or key.
  { "GET", "/", true, "GET", "", "" },
};

/* #endregion */

TEST_F(HandoffHelperImplSubsysTest, AuthorizationParamConstruct)
{
  for (const auto& t : eak_unit) {
    DEFINE_REQ_STATE;

    TestClient cio;
    // Set a header that should be included in the params.
    cio.get_env().set("HTTP_X_AMZ_FOO", "bar");
    s.cio = &cio;

    auto test_desc = fmt::format(FMT_STRING("for test: {} {} exp:{}"), t.method, t.r_uri, t.expected_pass);
    s.info.method = t.method.c_str();
    s.relative_uri = t.r_uri;

    auto param = rgw::AuthorizationParameters(&dpp, &s);

    if (!t.expected_pass) {
      EXPECT_FALSE(param.valid()) << test_desc;
      EXPECT_ANY_THROW(param.method()) << test_desc;
      EXPECT_ANY_THROW(param.bucket_name()) << test_desc;
      EXPECT_ANY_THROW(param.object_key_name()) << test_desc;
    } else {
      ASSERT_TRUE(param.valid()) << test_desc;
      EXPECT_EQ(param.method(), t.exp_method) << test_desc;
      EXPECT_EQ(param.bucket_name(), t.exp_bucket) << test_desc;
      EXPECT_EQ(param.object_key_name(), t.exp_object_key) << test_desc;
      // Any valid request should have the headers.
      ASSERT_NE(param.http_headers().find("x-amz-foo"), param.http_headers().end()) << test_desc;
      EXPECT_EQ(param.http_headers().at("x-amz-foo"), "bar") << test_desc;
    }
  }
}

// Test AuthServiceClient::_translate_authenticator_error_code().
TEST_F(HandoffHelperImplSubsysTest, TestReturnCodeMapping)
{
  // There's no need to be exhausive here, that's just copying an array or
  // implementing a big switch. Check a few representative values, and check
  // the cases where there's no mapping to make sure we're properly
  // defaulting.

  using err_type = authenticator::v1::S3ErrorDetails::Type;
  HandoffAuthResult res { "testid", "bar" };

  // Test a sample of standard responses.
  res = AuthServiceClient::_translate_authenticator_error_code(err_type::S3ErrorDetails_Type_TYPE_ACCESS_DENIED, 403, "foo");
  ASSERT_TRUE(res.is_err());
  EXPECT_EQ(res.code(), EACCES);
  res = AuthServiceClient::_translate_authenticator_error_code(err_type::S3ErrorDetails_Type_TYPE_AUTHORIZATION_HEADER_MALFORMED, 400, "foo");
  ASSERT_TRUE(res.is_err());
  EXPECT_EQ(res.code(), ERR_INVALID_REQUEST);
  res = AuthServiceClient::_translate_authenticator_error_code(err_type::S3ErrorDetails_Type_TYPE_SIGNATURE_DOES_NOT_MATCH, 403, "foo");
  ASSERT_TRUE(res.is_err());
  EXPECT_EQ(res.code(), ERR_SIGNATURE_NO_MATCH);

  // Test the way we handle the 'no mapping' case.

  // Unspecified (no mapping), request a 403. We should get an 'EACCES'.
  res = AuthServiceClient::_translate_authenticator_error_code(err_type::S3ErrorDetails_Type_TYPE_UNSPECIFIED, 403, "foo");
  ASSERT_TRUE(res.is_err());
  EXPECT_EQ(res.code(), EACCES);
  // Unspecified (no mapping), request a 400. We should get an 'EINVAL'.
  res = AuthServiceClient::_translate_authenticator_error_code(err_type::S3ErrorDetails_Type_TYPE_UNSPECIFIED, 400, "foo");
  ASSERT_TRUE(res.is_err());
  EXPECT_EQ(res.code(), EINVAL);
  // Unspecified (no mapping), request a 404. We should get an 'ERR_NOT_FOUND'.
  res = AuthServiceClient::_translate_authenticator_error_code(err_type::S3ErrorDetails_Type_TYPE_UNSPECIFIED, 404, "foo");
  ASSERT_TRUE(res.is_err());
  EXPECT_EQ(res.code(), ERR_NOT_FOUND);
  // Unspecified (no mapping), request a 666 (nonsense code). We should get an 'EACCES'.
  res = AuthServiceClient::_translate_authenticator_error_code(err_type::S3ErrorDetails_Type_TYPE_UNSPECIFIED, 666, "foo");
  ASSERT_TRUE(res.is_err());
  EXPECT_EQ(res.code(), EACCES);
}

// Regression: Don't return an empty grpc::ChannelArguments().
TEST(TestHandoffGRPCChannel, DefaultChannelArgsAreNotEmpty)
{
  HandoffGRPCChannel gc("foo");
  grpc::ChannelArguments args = gc.get_default_channel_args(g_ceph_context);
  grpc_channel_args ca = args.c_channel_args();
  ASSERT_TRUE(ca.num_args > 0) << "Expected at least one argument";
  std::unordered_map<std::string, int> int_args;
  for (size_t n = 0; n < ca.num_args; n++) {
    if (ca.args[n].type == GRPC_ARG_INTEGER) {
      int_args[ca.args[n].key] = ca.args[n].value.integer;
    }
  }
  // We expect at least three items to be set, there may be more depending on
  // the return from grpc::ChannelArguments().
  ASSERT_GE(int_args.size(), 3) << "Expected at least three integer arguments";
  // These defaults may change, the test will have to be updated to match.
  EXPECT_EQ(int_args["grpc.initial_reconnect_backoff_ms"], 1000);
  EXPECT_EQ(int_args["grpc.min_reconnect_backoff_ms"], 20000);
  EXPECT_EQ(int_args["grpc.max_reconnect_backoff_ms"], 120000);
}

/* #region authz-grpc */

class TestAuthzImpl final : public authorizer::v1::AuthorizerService::Service {

public:
  TestAuthzImpl()
      : ::authorizer::v1::AuthorizerService::Service()
  {
    // It'd be lovely if C++20 ranges didn't suck.
    std::copy(standard_canned_answers_.begin(), standard_canned_answers_.end(), std::back_inserter(canned_answers_));
  }

  void set_canned_results(const std::vector<::authorizer::v1::AuthorizationResultCode>& canned)
  {
    canned_answers_ = canned;
  }

private:
  static constexpr std::array<::authorizer::v1::AuthorizationResultCode, 1> standard_canned_answers_ { ::authorizer::v1::AUTHORIZATION_RESULT_CODE_ALLOW };

  DoutPrefix dpp_ { g_ceph_context, ceph_subsys_rgw, "unittest gRPC authz server " };
  std::vector<::authorizer::v1::AuthorizationResultCode> canned_answers_;

  grpc::Status Ping(grpc::ServerContext* context, const authorizer::v1::PingRequest* request, authorizer::v1::PingResponse* response) override
  {
    ldpp_dout(&dpp_, 20) << __func__ << ": enter" << dendl;
    auto common = response->mutable_common();
    // Only the authorization_id has to match. We don't really care about the
    // timestamp.
    common->set_authorization_id(request->common().authorization_id());
    ldpp_dout(&dpp_, 20) << __func__ << ": exit OK" << dendl;
    return grpc::Status::OK;
  }

  grpc::Status AuthorizeV2(grpc::ServerContext* context, const authorizer::v1::AuthorizeV2Request* request, authorizer::v1::AuthorizeV2Response* response) override
  {
    ldpp_dout(&dpp_, 20) << __func__ << ": enter" << dendl;
    ldpp_dout(&dpp_, 20) << "Request: " << *request << dendl;

    // Just create matching answers and copy in the canned answer result
    // codes.
    for (size_t n = 0; n < request->questions_size(); n++) {
      auto a = response->add_answers();
      SetAuthorizationCommonTimestamp(a->mutable_common());
      a->mutable_common()->set_authorization_id(request->questions(n).common().authorization_id());
      size_t i = n % canned_answers_.size(); // Bound the index into canned_answers_.
      a->set_code(canned_answers_[i]);
    }

    ldpp_dout(&dpp_, 20) << "Response: " << *response << dendl;
    return grpc::Status::OK;
  }
};

/**
 * @brief Authorization gRPC servers test fixture.
 *
 * Note 'servers' - we're starting a mock authn server as well as the authz
 * server. It's easy enough to do.
 *
 * Use GRPCTestServer to implement the gRPC servers on a random port, then
 * configure the HandoffHelperImpl to use it. The tests then issue gRPC()
 * calls against the helper.
 *
 * You *MUST* call helper_init() if you're going to use the HandoffHelperImpl
 * at all! Otherwise the channel and store won't be set up. This isn't called
 * automatically because sometimes we want to modify the channel configuration
 * first.
 *
 * It also doesn't implicitly start the server, you have to call start_test().
 * This is so we can easily test behaviour when the server isn't started.
 *
 * This actual-server approach has the virtue of being a somewhat faithful
 * client-side test. The server side is rather simplistic, obviously; but
 * that's probably ok.
 *
 * The fixture _will_ call server().stop() in TearDown, that feels relatively
 * safe.
 */
class AuthzGRPCTest : public ::testing::Test {

protected:
  HandoffHelperImpl hh_;
  optional_yield y_ = null_yield;
  DoutPrefix dpp_ { g_ceph_context, ceph_subsys_rgw, "unittest " };

  GRPCTestServer<TestAuthImpl> authn_server_;
  GRPCTestServer<TestAuthzImpl> authz_server_;

  // Don't start the server - some tests might want a chance to see what
  // happens without a server.
  void SetUp() override
  {
    // We're not really testing the authn_server here, so we can safely start
    // and stop it in the fixtures to save on boilerplate in the tests.
    authn_server().start();
  }

  void helper_init()
  {
    dpp_.get_cct()->_conf.set_val_or_die("rgw_handoff_enable_grpc", "true");
    dpp_.get_cct()->_conf.apply_changes(nullptr);
    ASSERT_EQ(dpp_.get_cct()->_conf->rgw_handoff_enable_grpc, true);
    // Note init() can take the server address URIs, it's normally defaulted
    // to empty which means 'use the Ceph configuration'.
    ASSERT_EQ(hh_.init(g_ceph_context, nullptr, authn_server_.address(), authz_server_.address()), 0);
  }

  // Will stop the server. There's no situation where we want it left around.
  void TearDown() override
  {
    authz_server().stop();
    authn_server().stop();
  }

  GRPCTestServer<TestAuthImpl>& authn_server() { return authn_server_; }
  GRPCTestServer<TestAuthzImpl>& authz_server() { return authz_server_; }
};

// This just tests we can instantiate the test classes.
TEST_F(AuthzGRPCTest, Null)
{
}

// Make sure server().start() is idempotent.
TEST_F(AuthzGRPCTest, MetaStart)
{
  authz_server().start();
  for (int n = 0; n < 1000; n++) {
    authz_server().start();
  }
  authz_server().stop();
}

// Make sure server().stop() is idempotent.
TEST_F(AuthzGRPCTest, MetaStop)
{
  authz_server().start();
  for (int n = 0; n < 1000; n++) {
    authz_server().stop();
  }
}

TEST_F(AuthzGRPCTest, HelperInit)
{
  authz_server().start();
  helper_init();
}

TEST_F(AuthzGRPCTest, Ping)
{
  authz_server().start();
  helper_init();
  auto client = AuthorizerClient(hh_.get_authz_channel().get_channel());
  auto id = "foo";
  auto status = client.Ping(id);
  ASSERT_TRUE(status);
}

TEST_F(AuthzGRPCTest, AuthorizeBasicSingleQuestion)
{
  authz_server().start();
  helper_init();
  auto client = AuthorizerClient(hh_.get_authz_channel().get_channel());

  DEFINE_REQ_STATE;
  TestClient cio;
  s.cio = &cio;

  s.handoff_authz = std::make_unique<HandoffAuthzState>(true);
  s.trans_id = "deadbeef";
  s.handoff_authz->set_bucket_name("bucket");
  s.handoff_authz->set_object_key_name("object");
  auto opt_req = PopulateAuthorizeRequest(&dpp_, &s, rgw::IAM::s3GetObject, 0, null_yield);
  ASSERT_THAT(opt_req, testing::Ne(std::nullopt));

  // Note that this will std::move the request!
  auto res = client.AuthorizeV2(*opt_req);
  opt_req = std::nullopt;

  ASSERT_TRUE(res.ok());
  ASSERT_TRUE(res.has_response());
  auto resp = res.response();
  ASSERT_EQ(resp.answers_size(), 1) << "expected 1 answer, got " << resp.answers_size();
  auto ans = resp.answers(0);
  ASSERT_TRUE(res.has_request());
  auto req = res.request();
  ASSERT_GT(ans.common().timestamp(), req.questions(0).common().timestamp()) << "timestamp ordering";
  ASSERT_EQ(ans.common().authorization_id(), req.questions(0).common().authorization_id()) << "authorization_id mismatch";
  ASSERT_EQ(ans.code(), AUTHORIZATION_RESULT_CODE_ALLOW) << "code mismatch";
}

TEST_F(AuthzGRPCTest, AuthorizeBasicMultipleQuestion)
{
  using namespace ::authorizer::v1;

  authz_server().start();
  helper_init();
  auto client = AuthorizerClient(hh_.get_authz_channel().get_channel());

  DEFINE_REQ_STATE;
  TestClient cio;
  s.cio = &cio;

  s.handoff_authz = std::make_unique<HandoffAuthzState>(true);
  s.trans_id = "deadbeef";
  s.handoff_authz->set_bucket_name("bucket");
  s.handoff_authz->set_object_key_name("object");
  // auto opt_req = PopulateAuthorizeRequest(&dpp_, &s, rgw::IAM::s3GetObject, null_yield);
  auto opt_req = PopulateAuthorizeRequest(&dpp_, &s, { rgw::IAM::s3GetObject, rgw::IAM::s3GetObjectLegalHold, rgw::IAM::s3GetObjectRetention }, 0, null_yield);
  ASSERT_THAT(opt_req, testing::Ne(std::nullopt)) << "expected request, got nullopt";

  // Note that this will std::move the request!
  auto res = client.AuthorizeV2(*opt_req);
  opt_req = std::nullopt;

  ASSERT_TRUE(res.ok());
  ASSERT_TRUE(res.has_request());
  auto req = res.request();
  ASSERT_TRUE(res.has_response());
  auto resp = res.response();
  ASSERT_EQ(resp.answers_size(), req.questions_size());
  for (int n = 0; n < resp.answers_size(); n++) {
    auto ans = resp.answers(n);
    ASSERT_GT(ans.common().timestamp(), req.questions(n).common().timestamp()) << "answer " << n << "timestamp ordering";
    ASSERT_EQ(ans.common().authorization_id(), req.questions(n).common().authorization_id())
        << "answer " << n << "authorization_id mismatch";
    ASSERT_EQ(ans.code(), AUTHORIZATION_RESULT_CODE_ALLOW) << "answer " << n << "code mismatch";
  }
}

TEST_F(AuthzGRPCTest, AuthorizeBasicSingleQuestionExpectedFail)
{
  authz_server().start();
  helper_init();
  auto client = AuthorizerClient(hh_.get_authz_channel().get_channel());

  DEFINE_REQ_STATE;
  TestClient cio;
  s.cio = &cio;

  s.handoff_authz = std::make_unique<HandoffAuthzState>(true);
  s.trans_id = "deadbeef";
  s.handoff_authz->set_bucket_name("bucket");
  s.handoff_authz->set_object_key_name("object");
  auto opt_req = PopulateAuthorizeRequest(&dpp_, &s, rgw::IAM::s3GetObject, 0, null_yield);
  ASSERT_THAT(opt_req, testing::Ne(std::nullopt));

  // Set a failure code.
  authz_server().instance()->set_canned_results({ ::authorizer::v1::AUTHORIZATION_RESULT_CODE_DENY });

  // Note that this will std::move the request!
  auto res = client.AuthorizeV2(*opt_req);
  opt_req = std::nullopt;

  ASSERT_TRUE(res.err()) << "expected err(), got " << res;

  ASSERT_TRUE(res.has_request());
  auto req = res.request();
  ASSERT_TRUE(res.has_response());
  auto resp = res.response();
  ASSERT_EQ(resp.answers_size(), 1) << "expected 1 answer, got " << resp.answers_size();
  auto ans = resp.answers(0);
  ASSERT_GT(ans.common().timestamp(), req.questions(0).common().timestamp()) << "timestamp ordering";
  ASSERT_EQ(ans.common().authorization_id(), req.questions(0).common().authorization_id()) << "authorization_id mismatch";
  ASSERT_EQ(ans.code(), AUTHORIZATION_RESULT_CODE_DENY) << "code mismatch";
}

TEST_F(AuthzGRPCTest, AuthorizeBasicMultipleQuestionExpectedFail)
{
  authz_server().start();
  helper_init();
  auto client = AuthorizerClient(hh_.get_authz_channel().get_channel());

  DEFINE_REQ_STATE;
  TestClient cio;
  s.cio = &cio;

  s.handoff_authz = std::make_unique<HandoffAuthzState>(true);
  s.trans_id = "deadbeef";
  s.handoff_authz->set_bucket_name("bucket");
  s.handoff_authz->set_object_key_name("object");
  // auto opt_req = PopulateAuthorizeRequest(&dpp_, &s, rgw::IAM::s3GetObject, null_yield);
  auto opt_req = PopulateAuthorizeRequest(&dpp_, &s, { rgw::IAM::s3GetObject, rgw::IAM::s3GetObjectLegalHold, rgw::IAM::s3GetObjectRetention }, 0, null_yield);
  ASSERT_THAT(opt_req, testing::Ne(std::nullopt));

  // Set a failure code for the last question.
  using namespace ::authorizer::v1;
  auto cr = std::vector<AuthorizationResultCode> { AUTHORIZATION_RESULT_CODE_ALLOW, AUTHORIZATION_RESULT_CODE_ALLOW, AUTHORIZATION_RESULT_CODE_DENY };
  authz_server().instance()->set_canned_results(cr);

  // Note that this will std::move the request!
  auto res = client.AuthorizeV2(*opt_req);
  opt_req = std::nullopt;

  ASSERT_TRUE(res.err()) << "expected err(), got " << res;

  ASSERT_TRUE(res.has_request());
  auto req = res.request();
  ASSERT_TRUE(res.has_response());
  auto resp = res.response();
  ASSERT_EQ(resp.answers_size(), req.questions_size());
  for (size_t n = 0; n < resp.answers_size(); n++) {
    auto ans = resp.answers(n);
    ASSERT_GT(ans.common().timestamp(), req.questions(n).common().timestamp()) << "answer " << n << "timestamp ordering";
    ASSERT_EQ(ans.common().authorization_id(), req.questions(n).common().authorization_id())
        << "answer " << n << "authorization_id mismatch";
    ASSERT_EQ(ans.code(), cr[n]) << "answer " << n << "code mismatch";
  }
}

// Authz utility tests.

TEST_F(AuthzGRPCTest, PopulateAuthorizeRequestFailureCaseBadOp)
{
  DEFINE_REQ_STATE;
  s.handoff_authz = std::make_unique<HandoffAuthzState>(true);
  // 9999 is not a valid opcode.
  auto opt_req = PopulateAuthorizeRequest(&dpp_, &s, 9999, 0, null_yield);
  ASSERT_THAT(opt_req, testing::Eq(std::nullopt));
}

TEST_F(AuthzGRPCTest, PopulateAuthorizeRequestIAMEnvironmentMapping)
{
  DEFINE_REQ_STATE;
  TestClient cio;
  s.cio = &cio;

  s.trans_id = "deadbeef";

  s.handoff_authz = std::make_unique<HandoffAuthzState>(true);

  s.env.emplace("k1", "k1v1");
  s.env.emplace("k1", "k1v2");
  s.env.emplace("k2", "k2v1");

  auto opt_req = PopulateAuthorizeRequest(&dpp_, &s, rgw::IAM::s3GetObject, 0, null_yield);
  ASSERT_THAT(opt_req, testing::Ne(std::nullopt));
  auto& req = *opt_req;

  // std::string out;
  // std::ignore = google::protobuf::util::MessageToJsonString(req, &out);
  // std::cerr << "XXX: " << out << std::endl;

  auto& env = req.questions(0).environment();
  ASSERT_EQ(env.size(), 2);
  auto ek1_values = env.at("k1").values();
  ASSERT_EQ(ek1_values.size(), 2);
  std::sort(ek1_values.begin(), ek1_values.end());
  ASSERT_EQ(ek1_values.at(0), "k1v1");
  ASSERT_EQ(ek1_values.at(1), "k1v2");
  auto ek2_values = env.at("k2").values();
  ASSERT_EQ(ek2_values.size(), 1);
  ASSERT_EQ(ek2_values.at(0), "k2v1");
}

TEST_F(AuthzGRPCTest, PopulateAuthorizeRequestQueryParameters)
{
  DEFINE_REQ_STATE;
  TestClient cio;
  s.cio = &cio;

  s.trans_id = "deadbeef";

  s.handoff_authz = std::make_unique<HandoffAuthzState>(true);

  auto& param = s.info.args.get_params();
  param.emplace("versionId", "foo");
  ASSERT_EQ(s.info.args.get_params().size(), 1);

  auto opt_req = PopulateAuthorizeRequest(&dpp_, &s, rgw::IAM::s3GetObject, 0, null_yield);
  ASSERT_THAT(opt_req, testing::Ne(std::nullopt));
  auto& req = *opt_req;

  ASSERT_EQ(req.questions(0).query_parameters_size(), 1);
  auto& qp = req.questions(0).query_parameters();
  ASSERT_EQ(qp.at("versionId"), "foo");
}

TEST_F(AuthzGRPCTest, PopulateAuthorizeRequestXAmzHeaders)
{
  DEFINE_REQ_STATE;
  TestClient cio;
  cio.get_env().set("HTTP_X_AMZ_FOO", "bar");
  s.cio = &cio;

  s.trans_id = "deadbeef";

  s.handoff_authz = std::make_unique<HandoffAuthzState>(true);

  auto opt_req = PopulateAuthorizeRequest(&dpp_, &s, rgw::IAM::s3GetObject, 0, null_yield);
  ASSERT_THAT(opt_req, testing::Ne(std::nullopt));
  auto& req = *opt_req;

  ASSERT_EQ(req.questions(0).x_amz_headers_size(), 1);
  auto& xah = req.questions(0).x_amz_headers();
  ASSERT_EQ(xah.at("x-amz-foo"), "bar");
}

// Check we're setting extra data when we should.

// Fake object tag loader, does nothing and returns success. This is used
// instead of calling the SAL to load object attributes, which we can't fake
// without a lot of unnecessary machinery. We'll pass this function to
// PopulateAuthorizeDataRequest() and let it propagate through.
int null_object_tag_load(
    const DoutPrefixProvider* dpp,
    const req_state* s,
    objtag_map_type& obj_tags,
    optional_yield y)
{
  return 0;
}

class ObjectTagHolder {
  std::unordered_map<std::string, std::string> tags_;

public:
  void set(const std::string& k, const std::string& v)
  {
    tags_[k] = v;
  }

  std::string& operator[](const std::string& idx) { return tags_[idx]; }

  int object_tag_load(
      const DoutPrefixProvider* dpp,
      const req_state* s,
      objtag_map_type& obj_tags,
      optional_yield y)
  {
    for (const auto& [k, v] : tags_) {
      obj_tags[k] = v;
    }
    return 0;
  }

  // Return a function that can be passed to PopulateAuthorizeRequest() in
  // order to fake the loading of object tags.
  load_object_tags_function get_loader()
  {
    using namespace std::placeholders;
    return std::bind(&ObjectTagHolder::object_tag_load, this, _1, _2, _3, _4);
  }
}; // class ObjectTagHolder

TEST_F(AuthzGRPCTest, PopulateAuthorizeRequestExtraDataNone)
{
  DEFINE_REQ_STATE;
  TestClient cio;
  s.cio = &cio;

  // Set up a request with no extra data.
  s.handoff_authz = std::make_unique<HandoffAuthzState>(true);
  s.trans_id = "deadbeef";
  ObjectTagHolder tags;
  auto opt_req = PopulateAuthorizeRequest(&dpp_, &s, rgw::IAM::s3GetObject, 0,
      null_yield, tags.get_loader());
  ASSERT_THAT(opt_req, testing::Ne(std::nullopt));
  auto& q = opt_req->questions(0);
  ASSERT_FALSE(q.has_extra_data());
  ASSERT_FALSE(q.has_extra_data_provided());
}

TEST_F(AuthzGRPCTest, PopulateAuthorizeRequestExtraDataObjectTags)
{
  // Now set object tags in the extra data.
  DEFINE_REQ_STATE;
  TestClient cio;
  s.cio = &cio;

  // New request.
  s.handoff_authz = std::make_unique<HandoffAuthzState>(true);
  s.trans_id = "deadbeef";
  s.handoff_authz->set_object_tags_required(true);
  ObjectTagHolder tags;
  tags["ok1"] = "ok1v1";
  auto opt_req = PopulateAuthorizeRequest(&dpp_, &s, rgw::IAM::s3GetObject, 0,
      null_yield, tags.get_loader());
  ASSERT_THAT(opt_req, testing::Ne(std::nullopt));
  auto& q = opt_req->questions(0);
  ASSERT_TRUE(q.has_extra_data_provided());
  ASSERT_TRUE(q.extra_data_provided().object_key_tags());
  ASSERT_TRUE(q.has_extra_data());
  auto ot = q.extra_data().object_key_tags();
  ASSERT_TRUE(ot.find("ok1") != ot.end());
  ASSERT_EQ(ot.at("ok1"), "ok1v1");
}

TEST_F(AuthzGRPCTest, PopulateAuthorizeRequestExtraDataObjectTagsButNoFlag)
{
  // Now set object tags in the extra data.
  DEFINE_REQ_STATE;
  TestClient cio;
  s.cio = &cio;

  // New request.
  s.handoff_authz = std::make_unique<HandoffAuthzState>(true);
  s.trans_id = "deadbeef";
  s.handoff_authz->set_object_tags_required(false);
  ObjectTagHolder tags;
  tags["ok1"] = "ok1v1";
  auto opt_req = PopulateAuthorizeRequest(&dpp_, &s, rgw::IAM::s3GetObject, 0,
      null_yield, tags.get_loader());
  ASSERT_THAT(opt_req, testing::Ne(std::nullopt));
  auto& q = opt_req->questions(0);
  ASSERT_FALSE(q.has_extra_data());
  ASSERT_FALSE(q.has_extra_data_provided());
}

TEST_F(AuthzGRPCTest, PopulateAuthorizeRequestExtraDataObjectTagsFlagButNoData)
{
  // Now set object tags in the extra data.
  DEFINE_REQ_STATE;
  TestClient cio;
  s.cio = &cio;

  // New request.
  s.handoff_authz = std::make_unique<HandoffAuthzState>(true);
  s.trans_id = "deadbeef";
  // No tags set.
  s.handoff_authz->set_object_tags_required(true);
  ObjectTagHolder tags;
  auto opt_req = PopulateAuthorizeRequest(&dpp_, &s, rgw::IAM::s3GetObject, 0,
      null_yield, tags.get_loader());
  ASSERT_THAT(opt_req, testing::Ne(std::nullopt));
  auto& q = opt_req->questions(0);
  ASSERT_TRUE(q.has_extra_data_provided());
  ASSERT_TRUE(q.extra_data_provided().object_key_tags());
  ASSERT_TRUE(q.has_extra_data());
  auto ot = q.extra_data().object_key_tags();
  ASSERT_TRUE(ot.find("ok1") == ot.end()); // => not found.
}

/* #endregion */

TEST(AuthzState, TargetStack)
{
  // Test the target stack.
  HandoffAuthzState state(true);
  state.set_bucket_name("b1");
  state.set_object_key_name("o1");
  ASSERT_EQ(state.bucket_name(), "b1");
  ASSERT_EQ(state.object_key_name(), "o1");

  state.push_target();
  ASSERT_EQ(state.bucket_name(), "");
  ASSERT_EQ(state.object_key_name(), "");
  state.set_bucket_name("b2");
  state.set_object_key_name("o2");
  ASSERT_EQ(state.bucket_name(), "b2");
  ASSERT_EQ(state.object_key_name(), "o2");

  state.push_target("b3", "o3");
  ASSERT_EQ(state.bucket_name(), "b3");
  ASSERT_EQ(state.object_key_name(), "o3");

  state.pop_target();
  ASSERT_EQ(state.bucket_name(), "b2");
  ASSERT_EQ(state.object_key_name(), "o2");

  state.pop_target();
  ASSERT_EQ(state.bucket_name(), "b1");
  ASSERT_EQ(state.object_key_name(), "o1");
}

TEST(AuthzDeathTest, TargetStackPopEmpty)
{
  HandoffAuthzState state(true);
  ASSERT_DEATH(state.pop_target(), ".*empty Authz state target stack.*");
}

TEST(AuthzState, RequirementsStack)
{
  // Test the requirements stack.
  HandoffAuthzState state(true);
  ASSERT_FALSE(state.object_tags_required());
  state.set_object_tags_required(true); // current == true, stack = empty
  ASSERT_TRUE(state.object_tags_required());
  state.push_requirements(); // current = false, stack[0] = true
  ASSERT_FALSE(state.object_tags_required());
  state.push_requirements(); // current = false, stack[0] = false, stack[1] = true
  state.set_object_tags_required(true); // current = true
  state.pop_requirements(); // current = false, stack[0] = true
  ASSERT_FALSE(state.object_tags_required());
  state.pop_requirements(); // current = true, stack = empty
  ASSERT_TRUE(state.object_tags_required());
}

TEST(AuthzDeathTest, RequirementsStackPopEmpty)
{
  HandoffAuthzState state(true);
  ASSERT_DEATH(state.pop_requirements(), ".*empty Authz state requirements stack.*");
}

} // namespace

// main() cribbed from test_http_manager.cc

int main(int argc, char** argv)
{
  auto args = argv_to_vec(argc, argv);
  auto cct = global_init(NULL, args, CEPH_ENTITY_TYPE_CLIENT, CODE_ENVIRONMENT_UTILITY, CINIT_FLAG_NO_DEFAULT_CONFIG_FILE);
  common_init_finish(g_ceph_context);

  // These can most likely go when HTTP mode is removed.
  rgw_http_client_init(cct->get());
  rgw_setup_saved_curl_handles();

  // Let the caller change the library debug level.
  if (std::getenv("TEST_DEBUG")) {
    std::string err;
    int level = strict_strtol(std::getenv("TEST_DEBUG"), 10, &err);
    if (err.empty()) {
      g_ceph_context->_conf->subsys.set_log_level(ceph_subsys_rgw, std::min(level, 30));
    }
  }

  ::testing::InitGoogleTest(&argc, argv);
  int r = RUN_ALL_TESTS();

  // These can most likely go when HTTP mode is removed.
  rgw_release_all_curl_handles();
  rgw_http_client_cleanup();

  return r;
}
